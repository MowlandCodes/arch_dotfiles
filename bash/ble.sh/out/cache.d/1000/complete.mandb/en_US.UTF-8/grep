--after-context=NUM=[1m[[0;36m-A[0;1m][m Print [4mNUM[24m lines of trailing context after matching lines. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
-A NUM Print [4mNUM[24m lines of trailing context after matching lines. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
-a Process a binary file as if it were text.
--basic-regexp [1m[[0;36m-G[0;1m][m Interpret [4mPATTERNS[24m as basic regular expressions (BREs, see below). This is the default.
--before-context=NUM=[1m[[0;36m-B[0;1m][m Print [4mNUM[24m lines of leading context before matching lines. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
--binary [1m[[0;36m-U[0;1m][m Treat the file(s) as binary. By default, under MS-DOS and MS-Windows, [1mgrep [22mguesses whether a file is text or binary as described for the [1m--binary-files [22moption. If [1mgrep [22mdecides the file is a text file, it strips the CR characters from the original file contents (to make regular expressions with [1m^ [22mand [1m$ [22mwork correctly). Specifying [1m-U [22moverrules this guesswork, causing all files to be read and passed to the matching mechanism verbatim.
--binary-files=TYPE=If a file's data or metadata indicate that the file contains binary data, assume that the file is of type [4mTYPE[24m. Non-text bytes indicate binary data.
-B NUM Print [4mNUM[24m lines of leading context before matching lines. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
-b Print the 0-based byte offset within the input file before each line of output. If [1m-o [22m([1m--only-matching[22m) is specified, print the offset of the matching part itself.
--byte-offset [1m[[0;36m-b[0;1m][m Print the 0-based byte offset within the input file before each line of output. If [1m-o [22m([1m--only-matching[22m) is specified, print the offset of the matching part itself.
-C NUM Print [4mNUM[24m lines of output context. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
--color[=WHEN]=Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte offsets, and separators (for fields and groups of context lines) with escape sequences to display them in color on the terminal. The colors are defined by the environment variable [1mGREP_COLORS[22m. [4mWHEN[24m is [1mnever[22m, [1malways[22m, or [1mauto[22m.
--colour[=WHEN]=Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte offsets, and separators (for fields and groups of context lines) with escape sequences to display them in color on the terminal. The colors are defined by the environment variable [1mGREP_COLORS[22m. [4mWHEN[24m is [1mnever[22m, [1malways[22m, or [1mauto[22m.
--context=NUM=Print [4mNUM[24m lines of output context. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
--count [1m[[0;36m-c[0;1m][m Suppress normal output.
-c Suppress normal output.
-D ACTION If an input file is a device, FIFO or socket, use [4mACTION[24m to process it. By default, [4mACTION[24m is [1mread[22m, which means that devices are read just as if they were ordinary files. If [4mACTION[24m is [1mskip[22m, devices are silently skipped.
-d ACTION If an input file is a directory, use [4mACTION[24m to process it. By default, [4mACTION[24m is [1mread[22m, i.e., read directories just as if they were ordinary files. If [4mACTION[24m is [1mskip[22m, silently skip directories. If [4mACTION[24m is [1mrecurse[22m, read all files under each directory, recursively, following symbolic links only if they are on the command line. This is equivalent to the [1m-r [22moption.
--dereference-recursive [1m[[0;36m-R[0;1m][m Read all files under each directory, recursively. Follow all symbolic links, unlike [1m-r[22m.
--devices=ACTION=[1m[[0;36m-D[0;1m][m If an input file is a device, FIFO or socket, use [4mACTION[24m to process it. By default, [4mACTION[24m is [1mread[22m, which means that devices are read just as if they were ordinary files. If [4mACTION[24m is [1mskip[22m, devices are silently skipped.
--directories=ACTION=[1m[[0;36m-d[0;1m][m If an input file is a directory, use [4mACTION[24m to process it. By default, [4mACTION[24m is [1mread[22m, i.e., read directories just as if they were ordinary files. If [4mACTION[24m is [1mskip[22m, silently skip directories. If [4mACTION[24m is [1mrecurse[22m, read all files under each directory, recursively, following symbolic links only if they are on the command line. This is equivalent to the [1m-r [22moption.
-E Interpret [4mPATTERNS[24m as extended regular expressions (EREs, see below).
-e PATTERNS Use [4mPATTERNS[24m as the patterns. If this option is used multiple times or is combined with the [1m-f [22m([1m--file[22m) option, search for all patterns given. This option can be used to protect a pattern beginning with ‚Äú-‚Äù.
--exclude-dir=GLOB=Skip any command-line directory with a name suffix that matches the pattern [4mGLOB[24m. When searching recursively, skip any subdirectory whose base name matches [4mGLOB[24m. Ignore any redundant trailing slashes in [4mGLOB[24m.
--exclude-from=FILE=Skip files whose base name matches any of the file-name globs read from [4mFILE[24m (using wildcard matching as described under [1m--exclude[22m).
--exclude=GLOB=Skip any command-line file with a name suffix that matches the pattern [4mGLOB[24m, using wildcard matching.
--extended-regexp [1m[[0;36m-E[0;1m][m Interpret [4mPATTERNS[24m as extended regular expressions (EREs, see below).
-f FILE Obtain patterns from [4mFILE[24m, one per line. If this option is used multiple times or is combined with the [1m-e [22m([1m--regexp[22m) option, search for all patterns given. The empty file contains zero patterns, and therefore matches nothing. If [4mFILE[24m is [1m- [22m, read patterns from standard input.
--file=FILE=[1m[[0;36m-f[0;1m][m Obtain patterns from [4mFILE[24m, one per line. If this option is used multiple times or is combined with the [1m-e [22m([1m--regexp[22m) option, search for all patterns given. The empty file contains zero patterns, and therefore matches nothing. If [4mFILE[24m is [1m- [22m, read patterns from standard input.
--files-with-matches [1m[[0;36m-l[0;1m][m Suppress normal output.
--files-without-match [1m[[0;36m-L[0;1m][m Suppress normal output.
-F Interpret [4mPATTERNS[24m as fixed strings, not regular expressions.
--fixed-strings [1m[[0;36m-F[0;1m][m Interpret [4mPATTERNS[24m as fixed strings, not regular expressions.
-G Interpret [4mPATTERNS[24m as basic regular expressions (BREs, see below). This is the default.
--group-separator=SEP=When [1m-A[22m, [1m-B[22m, or [1m-C [22mare in use, print [4mSEP[24m instead of [1m-- [22mbetween groups of lines.
--help Output a usage message and exit.
-H Print the file name for each match. This is the default when there is more than one file to search. This is a GNU extension.
-h Suppress the prefixing of file names on output. This is the default when there is only one file (or only standard input) to search.
--ignore-case [1m[[0;36m-i[0;1m][m Ignore case distinctions in patterns and input data, so that characters that differ only in case match each other.
-i Ignore case distinctions in patterns and input data, so that characters that differ only in case match each other.
--include=GLOB=Search only files whose base name matches [4mGLOB[24m (using wildcard matching as described under [1m--exclude[22m). If contradictory [1m--include [22mand [1m--exclude [22moptions are given, the last matching one wins. If no [1m--include [22mor [1m--exclude [22moptions match, a file is included unless the first such option is [1m--include[22m.
--initial-tab [1m[[0;36m-T[0;1m][m Make sure that the first character of actual line content lies on a tab stop, so that the alignment of tabs looks normal. This is useful with options that prefix their output to the actual content: [1m-H[22m,[1m-n[22m, and [1m-b[22m. In order to improve the probability that lines from a single file will all start at the same column, this also causes the line number and byte offset (if present) to be printed in a minimum size field width.
--invert-match [1m[[0;36m-v[0;1m][m Invert the sense of matching, to select non-matching lines.
-I Process a binary file as if it did not contain matching data.
--label=LABEL=Display input actually coming from standard input as input coming from file [4mLABEL[24m. This can be useful for commands that transform a file's contents before searching, e.g., [1mgzip -cd foo.gz | grep --label=foo -H some pattern[22m. See also the [1m-H [22moption.
--line-buffered Use line buffering on output. This can cause a performance penalty.
--line-number [1m[[0;36m-n[0;1m][m Prefix each line of output with the 1-based line number within its input file.
--line-regexp [1m[[0;36m-x[0;1m][m Select only those matches that exactly match the whole line. For a regular expression pattern, this is like parenthesizing the pattern and then surrounding it with [1m^ [22mand [1m$[22m.
-l Suppress normal output.
-L Suppress normal output.
--max-count=NUM=[1m[[0;36m-m[0;1m][m Stop reading a file after [4mNUM[24m matching lines. If [4mNUM[24m is zero, [1mgrep [22mstops right away without reading input. A [4mNUM[24m of -1 is treated as infinity and [1mgrep [22mdoes not stop.
-m NUM Stop reading a file after [4mNUM[24m matching lines. If [4mNUM[24m is zero, [1mgrep [22mstops right away without reading input. A [4mNUM[24m of -1 is treated as infinity and [1mgrep [22mdoes not stop.
--no-filename [1m[[0;36m-h[0;1m][m Suppress the prefixing of file names on output. This is the default when there is only one file (or only standard input) to search.
--no-group-separator When [1m-A[22m, [1m-B[22m, or [1m-C [22mare in use, do not print a separator between groups of lines.
--no-ignore-case Do not ignore case distinctions in patterns and input data. This is the default. This option is useful for passing to shell scripts that already use [1m-i[22m, to cancel its effects because the two options override each other.
--no-messages [1m[[0;36m-s[0;1m][m Suppress error messages about nonexistent or unreadable files.
-n Prefix each line of output with the 1-based line number within its input file.
--null [1m[[0;36m-Z[0;1m][m Output a zero byte (the ASCII [1mNUL [22mcharacter) instead of the character that normally follows a file name. For example, [1mgrep -lZ [22moutputs a zero byte after each file name instead of the usual newline. This option makes the output unambiguous, even in the presence of file names containing unusual characters like newlines. This option can be used with commands like [1mfind -print0[22m, [1mperl -0[22m, [1msort -z[22m, and [1mxargs -0 [22mto process arbitrary file names, even those that contain newline characters.
--null-data [1m[[0;36m-z[0;1m][m Treat input and output data as sequences of lines, each terminated by a zero byte (the ASCII NUL character) instead of a newline. Like the [1m-Z [22mor [1m--null [22moption, this option can be used with commands like [1msort -z [22mto process arbitrary file names.
-NUM=NUM=Print [4mNUM[24m lines of output context. Places a line containing a group separator ([1m--[22m) between contiguous groups of matches. With the [1m-o [22mor [1m--only-matching [22moption, this has no effect and a warning is given.
--only-matching [1m[[0;36m-o[0;1m][m Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.
-o Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.
--perl-regexp [1m[[0;36m-P[0;1m][m Interpret [4mPATTERNS[24m as Perl-compatible regular expressions (PCREs). This option is experimental when combined with the [1m-z [22m([1m--null-data[22m) option, and [1mgrep -P [22mmay warn of unimplemented features.
-P Interpret [4mPATTERNS[24m as Perl-compatible regular expressions (PCREs). This option is experimental when combined with the [1m-z [22m([1m--null-data[22m) option, and [1mgrep -P [22mmay warn of unimplemented features.
-q Quiet.
--quiet [1m[[0;36m-q[0;1m][m Quiet.
--recursive [1m[[0;36m-r[0;1m][m Read all files under each directory, recursively, following symbolic links only if they are on the command line. Note that if no file operand is given, [1mgrep [22msearches the working directory. This is equivalent to the [1m-d recurse [22moption.
--regexp=PATTERNS=[1m[[0;36m-e[0;1m][m Use [4mPATTERNS[24m as the patterns. If this option is used multiple times or is combined with the [1m-f [22m([1m--file[22m) option, search for all patterns given. This option can be used to protect a pattern beginning with ‚Äú-‚Äù.
-R Read all files under each directory, recursively. Follow all symbolic links, unlike [1m-r[22m.
-r Read all files under each directory, recursively, following symbolic links only if they are on the command line. Note that if no file operand is given, [1mgrep [22msearches the working directory. This is equivalent to the [1m-d recurse [22moption.
--silent Quiet.
-s Suppress error messages about nonexistent or unreadable files.
--text [1m[[0;36m-a[0;1m][m Process a binary file as if it were text.
-T Make sure that the first character of actual line content lies on a tab stop, so that the alignment of tabs looks normal. This is useful with options that prefix their output to the actual content: [1m-H[22m,[1m-n[22m, and [1m-b[22m. In order to improve the probability that lines from a single file will all start at the same column, this also causes the line number and byte offset (if present) to be printed in a minimum size field width.
-U Treat the file(s) as binary. By default, under MS-DOS and MS-Windows, [1mgrep [22mguesses whether a file is text or binary as described for the [1m--binary-files [22moption. If [1mgrep [22mdecides the file is a text file, it strips the CR characters from the original file contents (to make regular expressions with [1m^ [22mand [1m$ [22mwork correctly). Specifying [1m-U [22moverrules this guesswork, causing all files to be read and passed to the matching mechanism verbatim.
--version [1m[[0;36m-V[0;1m][m Output the version number of [1mgrep [22mand exit.
-v Invert the sense of matching, to select non-matching lines.
-V Output the version number of [1mgrep [22mand exit.
--with-filename [1m[[0;36m-H[0;1m][m Print the file name for each match. This is the default when there is more than one file to search. This is a GNU extension.
--word-regexp [1m[[0;36m-w[0;1m][m Select only those lines containing matches that form whole words. The test is that the matching substring must either be at the beginning of the line, or preceded by a non-word constituent character. Similarly, it must be either at the end of the line or followed by a non-word constituent character. Word-constituent characters are letters, digits, and the underscore. This option has no effect if [1m-x [22mis also specified.
-w Select only those lines containing matches that form whole words. The test is that the matching substring must either be at the beginning of the line, or preceded by a non-word constituent character. Similarly, it must be either at the end of the line or followed by a non-word constituent character. Word-constituent characters are letters, digits, and the underscore. This option has no effect if [1m-x [22mis also specified.
-x Select only those matches that exactly match the whole line. For a regular expression pattern, this is like parenthesizing the pattern and then surrounding it with [1m^ [22mand [1m$[22m.
-Z Output a zero byte (the ASCII [1mNUL [22mcharacter) instead of the character that normally follows a file name. For example, [1mgrep -lZ [22moutputs a zero byte after each file name instead of the usual newline. This option makes the output unambiguous, even in the presence of file names containing unusual characters like newlines. This option can be used with commands like [1mfind -print0[22m, [1mperl -0[22m, [1msort -z[22m, and [1mxargs -0 [22mto process arbitrary file names, even those that contain newline characters.
-z Treat input and output data as sequences of lines, each terminated by a zero byte (the ASCII NUL character) instead of a newline. Like the [1m-Z [22mor [1m--null [22moption, this option can be used with commands like [1msort -z [22mto process arbitrary file names.
